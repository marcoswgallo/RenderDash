import streamlit as st
import pandas as pd
import plotly.express as px
from pathlib import Path
import os
from datetime import datetime
import numpy as np

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="An√°lise de Dados Excel",
    page_icon="üìä",
    layout="wide"
)

# Fun√ß√£o para obter o caminho base do projeto
def get_project_root():
    """Retorna o caminho base do projeto"""
    script_path = Path(__file__).resolve()  # Caminho absoluto do script atual
    return script_path.parent.parent  # Volta dois n√≠veis (src -> raiz do projeto)

# Fun√ß√£o para listar arquivos Excel dispon√≠veis
def list_excel_files():
    project_root = get_project_root()
    data_dir = project_root / "data"
    excel_files = []
    
    if data_dir.exists():
        for year_dir in data_dir.glob("*"):
            if year_dir.is_dir():
                for excel_file in year_dir.glob("*.xlsx"):
                    # Armazena o caminho completo e o nome para exibi√ß√£o
                    excel_files.append({
                        'path': excel_file,
                        'display_name': f"{excel_file.parent.name}/{excel_file.stem}"
                    })
    return sorted(excel_files, key=lambda x: x['display_name'])

# Fun√ß√£o para carregar dados
@st.cache_data
def load_data(file_path):
    try:
        # Especifica os tipos de dados na leitura
        dtype_dict = {
            'BASE': 'str',
            'SERVI√áO': 'str',
            'HABILIDADE DE TRABALHO': 'str',
            'STATUS ATIVIDADE': 'str',
            'PACOTE': 'str',
            'CLIENTE': 'str',
            'CIDADES': 'str',
            'NODE': 'str',
            'TECNICO': 'str',
            'LOGIN': 'str',
            'SUPERVISOR': 'str',
            'COD STATUS': 'str'
        }
        
        # Parse dates na leitura
        date_columns = ['DATA_TOA', 'DATA', 'IN√çCIO', 'FIM', 'DESLOCAMENTO']
        
        df = pd.read_excel(
            file_path,
            dtype=dtype_dict,
            parse_dates=date_columns
        )
        
        # Converte colunas num√©ricas explicitamente
        numeric_columns = {
            'COP REVERTEU': 'float64',
            'LATIDUDE': 'float64',
            'LONGITUDE': 'float64',
            'COD': 'float64',
            'TIPO OS': 'float64',
            'VALOR T√âCNICO': 'float64',
            'VALOR EMPRESA': 'float64',
            'PONTO': 'float64'
        }
        
        for col, dtype in numeric_columns.items():
            if col in df.columns:
                df[col] = pd.to_numeric(df[col], errors='coerce').astype(dtype)
        
        return df
    except Exception as e:
        st.error(f"Erro ao carregar arquivo: {e}")
        return None

# T√≠tulo principal
st.title("üìä Dashboard de An√°lise de Dados")

# Sidebar para filtros
with st.sidebar:
    st.header("üìÅ Sele√ß√£o de Arquivo")
    
    # Lista todos os arquivos Excel no diret√≥rio data
    project_root = get_project_root()
    data_dir = project_root / "data"
    excel_files = []
    for year in os.listdir(data_dir):
        year_dir = os.path.join(data_dir, year)
        if os.path.isdir(year_dir):
            for file in os.listdir(year_dir):
                if file.endswith('.xlsx'):
                    excel_files.append(os.path.join(year_dir, file))
    
    if excel_files:
        # Ordena os arquivos por data de modifica√ß√£o (mais recente primeiro)
        excel_files.sort(key=lambda x: os.path.getmtime(x), reverse=True)
        
        # Extrai apenas o nome do arquivo para exibi√ß√£o
        file_names = [os.path.basename(f) for f in excel_files]
        
        selected_file = st.selectbox(
            "Selecione o arquivo Excel:",
            range(len(excel_files)),
            format_func=lambda x: file_names[x]
        )
        
        # Carrega o arquivo selecionado
        df = load_data(excel_files[selected_file])
        
        if df is not None:
            st.success(f"‚úÖ Arquivo carregado com sucesso!")
            
            # Filtros por tipo de base
            st.header("üè¢ Filtros por Base")
            
            # Dicion√°rio com as bases por tipo
            bases = {
                'Instala√ß√£o': [
                    'BASE BAURURIBEIRAOOTUCATU',
                    'BASE CAMPINAS',
                    'BASE LIMEIRA',
                    'BASE PAULINIA',
                    'BASE PIRACICABA',
                    'BASE RIBEIRAO PRETO',
                    'BASE SAO JOSE DO RIO PRETO',
                    'BASE SOROCABA',
                    'BASE SUMARE',
                    'GPON BAURU',
                    'GPON RIBEIRAO PRETO'
                ],
                'Manuten√ß√£o': [
                    'BASE ARARAS VT',
                    'BASE BOTUCATU VT',
                    'BASE MDU ARARAS',
                    'BASE MDU BAURU',
                    'BASE MDU MOGI',
                    'BASE MDU PIRACICABA',
                    'BASE MDU SJRP',
                    'BASE PIRACICABA VT',
                    'BASE RIBEIR√ÉO VT',
                    'BASE SERTAOZINHO VT',
                    'BASE SUMARE VT',
                    'BASE VAR BAURU',
                    'BASE VAR PIRACICABA',
                    'BASE VAR SUMARE'
                ],
                'Desconex√£o': [
                    'DESCONEXAO',
                    'DESCONEX√ÉO BOTUCATU',
                    'DESCONEX√ÉO CAMPINAS',
                    'DESCONEXAO RIBEIRAO PRETO'
                ]
            }
            
            # Filtro por tipo de base
            tipo_base = st.multiselect(
                "Tipo de Base:",
                options=list(bases.keys()),
                default=list(bases.keys())
            )
            
            # Filtro por bases espec√≠ficas
            bases_selecionadas = []
            for tipo in tipo_base:
                bases_selecionadas.extend(bases[tipo])
            
            bases_filtro = st.multiselect(
                "Bases Espec√≠ficas:",
                options=bases_selecionadas,
                default=bases_selecionadas
            )
            
            # Aplica os filtros
            if bases_filtro:
                df = df[df['BASE'].isin(bases_filtro)]
            
            st.metric("Registros Filtrados", len(df))
    else:
        st.warning("Nenhum arquivo Excel encontrado no diret√≥rio data.")

# Layout principal
if 'df' in locals() and df is not None:
    # M√©tricas principais em uma linha
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Total de Registros", len(df))
    with col2:
        if 'DATA' in df.columns:
            try:
                # Tenta converter para datetime se ainda n√£o for
                if not pd.api.types.is_datetime64_any_dtype(df['DATA']):
                    data_col = pd.to_datetime(df['DATA'], errors='coerce')
                else:
                    data_col = df['DATA']
                
                periodo = f"{data_col.min().strftime('%d/%m/%Y')} at√© {data_col.max().strftime('%d/%m/%Y')}"
            except:
                periodo = "N/A"
        else:
            periodo = "N/A"
        st.metric("Per√≠odo", periodo)
    with col3:
        st.metric("Cidades √önicas", df['CIDADES'].nunique() if 'CIDADES' in df.columns else "N/A")

    # An√°lises e Visualiza√ß√µes
    st.header("üìà An√°lises e Visualiza√ß√µes")

    # 1. An√°lise por dia da semana
    if 'DATA' in df.columns:
        try:
            st.subheader("üìÖ Distribui√ß√£o por Dia da Semana")
            dias_semana = {
                0: 'Segunda', 1: 'Ter√ßa', 2: 'Quarta', 3: 'Quinta',
                4: 'Sexta', 5: 'S√°bado', 6: 'Domingo'
            }
            
            # Garante que a coluna √© datetime
            if not pd.api.types.is_datetime64_any_dtype(df['DATA']):
                df['DATA'] = pd.to_datetime(df['DATA'], errors='coerce')
            
            df_dias = df.copy()
            df_dias['Dia_Semana'] = df_dias['DATA'].dt.dayofweek.map(dias_semana)
            dias_contagem = df_dias['Dia_Semana'].value_counts().reset_index()
            dias_contagem.columns = ['Dia', 'Quantidade']
            
            fig_dias = px.bar(
                dias_contagem,
                x='Dia',
                y='Quantidade',
                title='Quantidade de Atividades por Dia da Semana'
            )
            st.plotly_chart(fig_dias, use_container_width=True)
        except Exception as e:
            st.warning(f"N√£o foi poss√≠vel gerar a an√°lise por dia da semana: {e}")

    # 2. An√°lise por cidade
    if 'CIDADES' in df.columns:
        st.subheader("üåÜ Top 10 Cidades")
        cidades_contagem = df['CIDADES'].value_counts().head(10).reset_index()
        cidades_contagem.columns = ['Cidade', 'Quantidade']
        
        fig_cidades = px.bar(
            cidades_contagem,
            x='Cidade',
            y='Quantidade',
            title='Top 10 Cidades com Mais Atividades'
        )
        st.plotly_chart(fig_cidades, use_container_width=True)

    # 3. An√°lise por tipo de servi√ßo
    if 'SERVI√áO' in df.columns:
        st.subheader("üîß Distribui√ß√£o por Tipo de Servi√ßo")
        fig_servico = px.pie(
            df['SERVI√áO'].value_counts().reset_index(),
            values='SERVI√áO',
            names='index',
            title='Distribui√ß√£o de Tipos de Servi√ßo'
        )
        st.plotly_chart(fig_servico, use_container_width=True)

    # 4. An√°lise de Status
    if 'STATUS ATIVIDADE' in df.columns:
        st.subheader("üìä Status das Atividades")
        fig_status = px.bar(
            df['STATUS ATIVIDADE'].value_counts().reset_index(),
            x='index',
            y='STATUS ATIVIDADE',
            title='Distribui√ß√£o de Status das Atividades'
        )
        st.plotly_chart(fig_status, use_container_width=True)

    # 5. An√°lise de Valores
    if all(col in df.columns for col in ['VALOR T√âCNICO', 'VALOR EMPRESA']):
        st.subheader("üí∞ An√°lise de Valores")
        col1, col2 = st.columns(2)
        
        with col1:
            st.metric("Valor Total T√©cnico", f"R$ {df['VALOR T√âCNICO'].sum():,.2f}")
            st.metric("M√©dia por Atividade", f"R$ {df['VALOR T√âCNICO'].mean():,.2f}")
        
        with col2:
            st.metric("Valor Total Empresa", f"R$ {df['VALOR EMPRESA'].sum():,.2f}")
            st.metric("M√©dia por Atividade", f"R$ {df['VALOR EMPRESA'].mean():,.2f}")

    # 6. An√°lise Temporal
    if 'DATA' in df.columns:
        st.subheader("üìà Evolu√ß√£o Temporal")
        try:
            # Agrupa por data e conta atividades
            daily_activities = df.groupby('DATA').size().reset_index(name='Quantidade')
            fig_temporal = px.line(
                daily_activities,
                x='DATA',
                y='Quantidade',
                title='Quantidade de Atividades por Dia'
            )
            st.plotly_chart(fig_temporal, use_container_width=True)
        except Exception as e:
            st.warning(f"N√£o foi poss√≠vel gerar a an√°lise temporal: {e}")

    # 7. An√°lise de Efici√™ncia
    if all(col in df.columns for col in ['IN√çCIO', 'FIM']):
        st.subheader("‚è±Ô∏è An√°lise de Tempo de Execu√ß√£o")
        try:
            # Converte para datetime se necess√°rio
            if not pd.api.types.is_datetime64_any_dtype(df['IN√çCIO']):
                df['IN√çCIO'] = pd.to_datetime(df['IN√çCIO'], errors='coerce')
            if not pd.api.types.is_datetime64_any_dtype(df['FIM']):
                df['FIM'] = pd.to_datetime(df['FIM'], errors='coerce')
            
            # Calcula dura√ß√£o em horas
            df['Dura√ß√£o'] = (df['FIM'] - df['IN√çCIO']).dt.total_seconds() / 3600
            
            fig_duracao = px.histogram(
                df[df['Dura√ß√£o'] > 0],  # Remove dura√ß√µes negativas ou zero
                x='Dura√ß√£o',
                title='Distribui√ß√£o do Tempo de Execu√ß√£o (horas)',
                nbins=30
            )
            st.plotly_chart(fig_duracao, use_container_width=True)
            
            # Estat√≠sticas de dura√ß√£o
            st.metric("Tempo M√©dio de Execu√ß√£o", f"{df['Dura√ß√£o'].mean():,.2f} horas")
            
        except Exception as e:
            st.warning(f"N√£o foi poss√≠vel gerar a an√°lise de tempo de execu√ß√£o: {e}")

else:
    st.info("üëà Selecione um arquivo na barra lateral para come√ßar a an√°lise.")
